apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ .Release.Name }}-integrate-db-creds-sa
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: {{ .Release.Name }}-integrate-db-creds-cr
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
rules:
- apiGroups: [""]
  resources:
  - secrets
  verbs:
  - get
  - create
  - patch
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: {{ .Release.Name }}-integrate-db-creds-cr-bind
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "0"
subjects:
- kind: ServiceAccount
  name: {{ .Release.Name }}-integrate-db-creds-sa
  namespace: {{ .Release.Namespace }}
roleRef:
  kind: ClusterRole
  name: '{{ .Release.Name }}-integrate-db-creds-cr'
  apiGroup: rbac.authorization.k8s.io
---
# creates a secret for schema hero to have credentials as well as for each service and processor
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}-integrate-db-creds"
  annotations:
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
    "helm.sh/hook-weight": "10"
spec:
  template:
    spec:
      serviceAccount: {{ .Release.Name }}-integrate-db-creds-sa
      restartPolicy: OnFailure
      terminationGracePeriodSeconds: 0
      {{- include "securitycontext" (dict "primary" .Values.haExpenseSplitter.securityContext) | nindent 6 }}
      containers:
      - name: "integrate-db-creds"
        image: "bitnami/kubectl:{{ .Capabilities.KubeVersion.Major }}.{{ .Capabilities.KubeVersion.Minor }}"
        imagePullPolicy: "IfNotPresent"
        command:
          - "/bin/bash"
          - "-ecx"
          - |
            CREDS=($(kubectl get secret -n '{{ .Values.haExpenseSplitter.db.adminUser.sourceSecret.namespace }}' '{{ .Values.haExpenseSplitter.db.adminUser.sourceSecret.name }}' \
              --template '{{ `{{` }} printf `%s %s` (index .data `{{ .Values.haExpenseSplitter.db.adminUser.sourceSecret.userKey }}` | base64decode) (index .data `{{ .Values.haExpenseSplitter.db.adminUser.sourceSecret.passwordKey }}` | base64decode) {{ `}}` }}' \
              ))
            ADMIN_USER=${CREDS[0]}
            ADMIN_PASSWORD=${CREDS[1]}
            kubectl create secret generic {{ .Values.haExpenseSplitter.db.adminUser.targetSecret.name }} \
              -n {{ .Release.Namespace }} \
              --save-config \
              --dry-run=client \
              --from-literal={{ include "dbUserKey" . }}=$ADMIN_USER --from-literal={{ include "dbPasswordKey" . }}=$ADMIN_PASSWORD \
              -o yaml | \
              kubectl apply -f -
          # TODO: create psql users with the help of the secrets created for services and processors
